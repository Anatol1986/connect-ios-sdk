//
//  OBNetwork.m
//  Outbound
//
//  Created by Emilien on 2015-04-19.
//  Copyright (c) 2015 Outbound.io. All rights reserved.
//

#import "OBNetwork.h"
#import "NSURLSession+OBJSON.h"

static NSString * const kBackgroundURLSessionIdentifier = @"io.outbound.urlsession";

@interface OBNetwork ()

/**-----------------------------------------------------------------------------
 * @name Private methods
 * -----------------------------------------------------------------------------
 */

+ (nullable NSMutableURLRequest *)requestWithPath:(NSString *)path APIKey:(NSString *)key;

/**
 @abstract A helper method to build the [NSURLRequest](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSURLRequest_Class/index.html) for an API call.
 @param path API call path. Possible paths as defined by the [Outbound API](https://github.com/outboundio/api) are `identify`, `track`, `apns/register`, `apns/disable`.
 @param key Host app API key.
 @param params API call parameters.
 @param error If an error occurs, upon return contains an NSError object that describes the problem.
 @discussion The NSURLRequest is generated by
 
- Building the endpoint URL by appending `/v2/[path]` to the OBServerUrl constant
- Setting HTTPMethod to `POST`
- Setting the timeout to the value of the OBNetworkTimeout constant
- Setting the `Content-Type` HTTP header to `application/json` and `X-Outbound-Key` to the value of the API key parameter
- Setting the `X-Outbound-GUID` to a unique string value for server side call deduping
- Serializing the parameters to JSON as the HTTPBody
 
 */
+ (nullable NSMutableURLRequest *)postRequestWithPath:(NSString *)path APIKey:(NSString *)key parameters:(NSDictionary *)params andError:(NSError * _Nullable *)error;

/**
 @abstract A helper method to print details about the network request and its response to the console.
 */
+ (void)debugRequest:(NSURLRequest *)request withStatusCode:(NSInteger)code error:(NSError *)error andJson:(NSObject *)json;

@end

@implementation OBNetwork

#pragma mark - Helpers

+ (NSURLRequest *)requestWithPath:(NSString *)path APIKey:(NSString *)key {
    NSParameterAssert(path != nil);
    NSParameterAssert(key != nil);

    // Build endpoint URL
    NSURL *serverURL = [NSURL URLWithString:OBServerUrl];
    NSURL *endpointURL = [NSURL URLWithString:path relativeToURL:serverURL].absoluteURL;

    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:endpointURL];
    request.timeoutInterval = OBNetworkTimeout;
    
    // Set headers
    [request setValue:@"application/json" forHTTPHeaderField:@"Content-Type"];
    [request setValue:key forHTTPHeaderField:@"X-Outbound-Key"];
    [request setValue:[NSUUID UUID].UUIDString forHTTPHeaderField:@"X-Outbound-GUID"];
    [request setValue:[NSString stringWithFormat:@"%@/%@", OBClientName, OBClientVersion] forHTTPHeaderField:@"X-Outbound-Client"];
    
    return [request copy];
}

+ (NSURLRequest *)postRequestWithPath:(NSString *)path APIKey:(NSString *)key parameters:(NSDictionary *)parameters andError:(NSError **)error {
    NSParameterAssert(path != nil);
    NSParameterAssert(key != nil);
    NSParameterAssert(parameters != nil);

    NSMutableURLRequest *request = [[self requestWithPath:path APIKey:key] mutableCopy];
    request.HTTPMethod = @"POST";
    
    // Serialize parameters into JSON
    NSError *serializationError = nil;
    NSData *payloadData = [NSJSONSerialization dataWithJSONObject:parameters options:0 error:&serializationError];

    if (payloadData != nil) {
        request.HTTPBody = payloadData;

        return [request copy];
    } else {
        if (error != NULL) {
            *error = serializationError;
        }

        return nil;
    }
}

+ (void)debugRequest:(NSURLRequest *)request withStatusCode:(NSInteger)code error:(NSError *)error andJson:(NSObject *)json {
    OBDebug(@"Network Request: %@ %@\n%@\n%@\n---\nResponse [%@]%@\n%@",
            request.HTTPMethod,
            [request.URL absoluteString],
            [request allHTTPHeaderFields],
            [[NSString alloc] initWithData:request.HTTPBody encoding:NSUTF8StringEncoding],
            @(code),
            error != nil ? [NSString stringWithFormat:@"\nError: %@", [error localizedDescription]] : @"",
            json);
}

#pragma mark - Action

+ (void)getPath:(NSString *)path withAPIKey:(NSString *)key andCompletion:(void (^)(id json, NSInteger statusCode, NSError *error))completion {
    NSParameterAssert(path != nil);
    NSParameterAssert(key != nil);
    NSParameterAssert(completion != nil);

    NSURLRequest *request = [self requestWithPath:path APIKey:key];
    NSURLSessionDataTask *dataTask = [[NSURLSession sharedSession] ob_jsonDataTaskForRequest:request completion:^(id json, NSURLResponse *response, NSError *error) {
        NSParameterAssert(response == nil || [response isKindOfClass:[NSHTTPURLResponse class]]);

        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        [self debugRequest:request withStatusCode:httpResponse.statusCode error:error andJson:json];

        completion(json, httpResponse.statusCode, error);
    }];

    [dataTask resume];
}

+ (void)postPath:(NSString *)path withAPIKey:(NSString *)key parameters:(NSDictionary *)parameters andCompletion:(void (^)(id json, NSInteger statusCode, NSError *error))completion {
    NSParameterAssert(path != nil);
    NSParameterAssert(key != nil);
    NSParameterAssert(parameters != nil);
    NSParameterAssert(completion != nil);

    NSError *error = nil;
    NSURLRequest *request = [self postRequestWithPath:path APIKey:key parameters:parameters andError:&error];

    if (request != nil) {
        NSURLSessionDataTask *dataTask = [[NSURLSession sharedSession] ob_jsonDataTaskForRequest:request completion:^(id json, NSURLResponse *response, NSError *error) {
            NSParameterAssert([response isKindOfClass:[NSHTTPURLResponse class]]);

            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
            [self debugRequest:request withStatusCode:httpResponse.statusCode error:error andJson:json];

            completion(json, httpResponse.statusCode, error);
        }];

        [dataTask resume];
    } else {
        dispatch_async(dispatch_get_main_queue(), ^{
            [self debugRequest:request withStatusCode:0 error:error andJson:nil];
            completion(nil, 0, error);
        });
    }
}

@end
